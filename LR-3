#include <stdio.h>
#include <limits.h>

#define N 5
#define AGING_FACTOR 0.1

typedef struct {
    int pid;
    int arrival;
    int burst;
    int priority;

    int start;
    int finish;
    int waiting;
    int turnaround;

    int completed;
} Process;

/* ---------- SJF (non-preemptive) ---------- */
void sjf(Process p[]) {
    int time = 0, done = 0;

    while (done < N) {
        int idx = -1;
        int minBurst = INT_MAX;

        for (int i = 0; i < N; i++) {
            if (!p[i].completed && p[i].arrival <= time) {
                if (p[i].burst < minBurst) {
                    minBurst = p[i].burst;
                    idx = i;
                }
            }
        }

        if (idx == -1) {
            time++;
            continue;
        }

        p[idx].start = time;
        time += p[idx].burst;
        p[idx].finish = time;

        p[idx].waiting = p[idx].start - p[idx].arrival;
        p[idx].turnaround = p[idx].finish - p[idx].arrival;
        p[idx].completed = 1;

        done++;
    }
}

/* ---------- Priority Scheduling with Aging ---------- */
void priority_aging(Process p[]) {
    int time = 0, done = 0;
    double dynamicPriority[N];

    for (int i = 0; i < N; i++) {
        dynamicPriority[i] = p[i].priority;
    }

    while (done < N) {
        int idx = -1;
        double bestPriority = 1e9;

        for (int i = 0; i < N; i++) {
            if (!p[i].completed && p[i].arrival <= time) {
                int wait = time - p[i].arrival;
                dynamicPriority[i] = p[i].priority - AGING_FACTOR * wait;

                if (dynamicPriority[i] < bestPriority) {
                    bestPriority = dynamicPriority[i];
                    idx = i;
                }
            }
        }

        if (idx == -1) {
            time++;
            continue;
        }

        p[idx].start = time;
        time += p[idx].burst;
        p[idx].finish = time;

        p[idx].waiting = p[idx].start - p[idx].arrival;
        p[idx].turnaround = p[idx].finish - p[idx].arrival;
        p[idx].completed = 1;

        done++;
    }
}

/* ---------- Utility ---------- */
void reset(Process p[], Process original[]) {
    for (int i = 0; i < N; i++) {
        p[i] = original[i];
        p[i].completed = 0;
    }
}

void print_results(Process p[], const char *title) {
    double avgWait = 0, avgTurn = 0;

    printf("\n%s\n", title);
    printf("PID  Arr  Burst  Prio  Start  Finish  Wait  Turn\n");

    for (int i = 0; i < N; i++) {
        printf("P%d   %3d   %3d     %3d    %3d     %3d     %3d    %3d\n",
               p[i].pid, p[i].arrival, p[i].burst, p[i].priority,
               p[i].start, p[i].finish, p[i].waiting, p[i].turnaround);

        avgWait += p[i].waiting;
        avgTurn += p[i].turnaround;
    }

    printf("Average waiting time   = %.2f\n", avgWait / N);
    printf("Average turnaround time= %.2f\n", avgTurn / N);
}

/* ---------- Main ---------- */
int main() {
    Process original[N] = {
        {1, 0, 7, 3},
        {2, 1, 4, 1},
        {3, 2, 1, 4},
        {4, 3, 4, 2},
        {5, 4, 3, 5}
    };

    Process p[N];

    reset(p, original);
    sjf(p);
    print_results(p, "SJF Scheduling");

    reset(p, original);
    priority_aging(p);
    print_results(p, "Priority Scheduling with Aging");

    return 0;
}
